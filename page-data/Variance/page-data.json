{"componentChunkName":"component---src-templates-post-template-tsx","path":"/Variance/","result":{"data":{"allMarkdownRemark":{"edges":[{"node":{"html":"<h3>Variance</h3>\n<p>타입 시스템에는 <strong>변성</strong>(<strong>Variance</strong>)의 개념이 존재합니다.</p>\n<p>기저 타입(Base type)은 같지만, 타입 인자(Type argument)가 다른, 타입 간 호환성에 관한 개념입니다.</p>\n<p>종류는 <strong>공변성</strong>(<strong>Covariance</strong>), <strong>반공변성</strong>(<strong>Contravariance</strong>), <strong>이변성</strong>(<strong>Bivariance</strong>), <strong>불변성</strong>(<strong>Invariance</strong>)이 있습니다.</p>\n<br>\n<p>또한 타입 시스템에는 <strong>Subtyping</strong>이라는 타입 간 관계의 개념이 존재합니다.</p>\n<p><u>A가 B를 대체할 수 있다면</u>, A는 B의 <strong>Subtype</strong>이 되고, B는 A의 <strong>Supertype</strong>이 됩니다. (표기 : <code class=\"language-text\">A &lt;: B</code>)</p>\n<p><br><br></p>\n<ul>\n<li>\n<h5>공변성(Covariance)</h5>\n</li>\n</ul>\n<br>\n<p>타입 간 관계(Subtype)가 <strong>유지</strong>되는 성질입니다.</p>\n<p>ex) <u>A가 B의 서브타입이면</u>, <code class=\"language-text\">F&lt;A></code>가 <code class=\"language-text\">F&lt;B></code>의 서브타입.</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">A &lt;: B  =>  F&lt;A> &lt;: F&lt;B></code></pre></div>\n<br>\n<ul>\n<li>\n<h5>반공변성(Contravariance)</h5>\n</li>\n</ul>\n<br>\n<p>타입 간 관계(Subtype)가 <strong>역전</strong>되는 성질입니다.</p>\n<p>ex) <u>A가 B의 서브타입이면</u>, <code class=\"language-text\">F&lt;B></code>가 <code class=\"language-text\">F&lt;A></code>의 서브타입.</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">A &lt;: B  =>  F&lt;A> :> F&lt;B></code></pre></div>\n<br>\n<ul>\n<li>\n<h5>이변성(Bivariance)</h5>\n</li>\n</ul>\n<br>\n<p>공변성과 반공변성을 모두 갖는, <strong>타입 간 호환이 자유로운 성질</strong>입니다.</p>\n<br>\n<ul>\n<li>\n<h5>불변성(Invariance)</h5>\n</li>\n</ul>\n<br>\n<p>타입 간 관계(Subtype)가 존재하지 않아서, 동일한 타입이 아니면 <strong>타입 간 호환이 불가한 성질</strong>입니다.</p>\n<hr>\n<h3>In TypeScript</h3>\n<h5>Structural type system</h5>\n<br>\n<p>타입스크립트는 <strong>구조적 타입 시스템</strong>(<strong>Structural type system</strong> / <strong>Structural Subtyping</strong>)을 사용합니다.</p>\n<p>이름이나 상속과 관계 없이, 타입의 내부 구조에 의해 타입 간 관계, 호환성이 결정됩니다.</p>\n<p>따라서 <u><strong>Subtyping의 대체 가능성을 타입의 구조로 판단</strong></u>합니다.</p>\n<p><br><br></p>\n<h5>strictFunctionTypes</h5>\n<div class=\"gatsby-highlight\" data-language=\"ts\"><pre class=\"language-ts\"><code class=\"language-ts\"><span class=\"token keyword\">class</span> <span class=\"token class-name\">Animal</span> <span class=\"token punctuation\">{</span>\r\n  animal<span class=\"token operator\">:</span> <span class=\"token keyword\">undefined</span><span class=\"token punctuation\">;</span>\r\n<span class=\"token punctuation\">}</span>\r\n<span class=\"token keyword\">class</span> <span class=\"token class-name\">Dog</span> <span class=\"token punctuation\">{</span>\r\n  animal<span class=\"token operator\">:</span> <span class=\"token keyword\">undefined</span><span class=\"token punctuation\">;</span>\r\n  dog<span class=\"token operator\">:</span> <span class=\"token keyword\">undefined</span><span class=\"token punctuation\">;</span>\r\n<span class=\"token punctuation\">}</span></code></pre></div>\n<ul>\n<li>여기서 Dog가 Animal을 대체할 수 있으므로, <u>Dog는 Animal의 서브타입</u>입니다. <code class=\"language-text\">Dog &lt;: Animal</code></li>\n</ul>\n<br>\n<p>다음은 두 타입을 제네릭으로 사용하는 세 가지 경우입니다.</p>\n<br>\n<h6>1. 배열 값의 타입으로 사용하는 경우</h6>\n<div class=\"gatsby-highlight\" data-language=\"ts\"><pre class=\"language-ts\"><code class=\"language-ts\"><span class=\"token keyword\">let</span> arr1<span class=\"token operator\">:</span> <span class=\"token builtin\">Array</span><span class=\"token operator\">&lt;</span>Animal<span class=\"token operator\">></span> <span class=\"token operator\">=</span> <span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\r\n<span class=\"token keyword\">let</span> arr2<span class=\"token operator\">:</span> <span class=\"token builtin\">Array</span><span class=\"token operator\">&lt;</span>Dog<span class=\"token operator\">></span> <span class=\"token operator\">=</span> <span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\r\narr1 <span class=\"token operator\">=</span> arr2<span class=\"token punctuation\">;</span> <span class=\"token comment\">// Ok</span>\r\narr2 <span class=\"token operator\">=</span> arr1<span class=\"token punctuation\">;</span> <span class=\"token comment\">// Error with --strictFunctionTypes</span></code></pre></div>\n<ul>\n<li>타입 간 관계가 <strong>유지</strong>됩니다. 즉, <strong>공변성</strong>(Covariance)을 가집니다. <code class=\"language-text\">Array&lt;Dog> &lt;: Array&lt;Animal></code></li>\n</ul>\n<p><br><br></p>\n<h6>2. 함수 반환값의 타입으로 사용하는 경우</h6>\n<div class=\"gatsby-highlight\" data-language=\"ts\"><pre class=\"language-ts\"><code class=\"language-ts\"><span class=\"token keyword\">type</span> <span class=\"token class-name\"><span class=\"token constant\">F1</span><span class=\"token operator\">&lt;</span><span class=\"token constant\">T</span><span class=\"token operator\">></span></span> <span class=\"token operator\">=</span> <span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">=></span> <span class=\"token constant\">T</span><span class=\"token punctuation\">;</span>\r\n<span class=\"token keyword\">let</span> f1<span class=\"token operator\">:</span> <span class=\"token constant\">F1</span><span class=\"token operator\">&lt;</span>Animal<span class=\"token operator\">></span> <span class=\"token operator\">=</span> <span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">=></span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">Animal</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\r\n<span class=\"token keyword\">let</span> f2<span class=\"token operator\">:</span> <span class=\"token constant\">F1</span><span class=\"token operator\">&lt;</span>Dog<span class=\"token operator\">></span> <span class=\"token operator\">=</span> <span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">=></span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">Dog</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\r\nf1 <span class=\"token operator\">=</span> f2<span class=\"token punctuation\">;</span> <span class=\"token comment\">// Ok</span>\r\nf2 <span class=\"token operator\">=</span> f1<span class=\"token punctuation\">;</span> <span class=\"token comment\">// Error with --strictFunctionTypes</span></code></pre></div>\n<ul>\n<li>타입 간 관계가 <strong>유지</strong>됩니다. 즉, <strong>공변성</strong>(Covariance)을 가집니다. <code class=\"language-text\">F1&lt;Dog> &lt;: F1&lt;Animal></code></li>\n</ul>\n<p><br><br></p>\n<h6>3. 함수 매개변수의 타입으로 사용하는 경우</h6>\n<div class=\"gatsby-highlight\" data-language=\"ts\"><pre class=\"language-ts\"><code class=\"language-ts\"><span class=\"token keyword\">type</span> <span class=\"token class-name\"><span class=\"token constant\">F2</span><span class=\"token operator\">&lt;</span><span class=\"token constant\">T</span><span class=\"token operator\">></span></span> <span class=\"token operator\">=</span> <span class=\"token punctuation\">(</span>x<span class=\"token operator\">:</span> <span class=\"token constant\">T</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">=></span> <span class=\"token keyword\">void</span><span class=\"token punctuation\">;</span>\r\n<span class=\"token keyword\">let</span> f3<span class=\"token operator\">:</span> <span class=\"token constant\">F2</span><span class=\"token operator\">&lt;</span>Animal<span class=\"token operator\">></span> <span class=\"token operator\">=</span> <span class=\"token punctuation\">(</span>x<span class=\"token operator\">:</span> Animal<span class=\"token punctuation\">)</span> <span class=\"token operator\">=></span> <span class=\"token punctuation\">{</span><span class=\"token punctuation\">}</span><span class=\"token punctuation\">;</span>\r\n<span class=\"token keyword\">let</span> f4<span class=\"token operator\">:</span> <span class=\"token constant\">F2</span><span class=\"token operator\">&lt;</span>Dog<span class=\"token operator\">></span> <span class=\"token operator\">=</span> <span class=\"token punctuation\">(</span>x<span class=\"token operator\">:</span> Dog<span class=\"token punctuation\">)</span> <span class=\"token operator\">=></span> <span class=\"token punctuation\">{</span><span class=\"token punctuation\">}</span><span class=\"token punctuation\">;</span>\r\nf3 <span class=\"token operator\">=</span> f4<span class=\"token punctuation\">;</span> <span class=\"token comment\">// Error with --strictFunctionTypes</span>\r\nf4 <span class=\"token operator\">=</span> f3<span class=\"token punctuation\">;</span> <span class=\"token comment\">// Ok</span></code></pre></div>\n<ul>\n<li>타입 간 관계가 <strong>역전</strong>됩니다. 즉, <strong>반공변성</strong>(Contravariance)을 가집니다. <code class=\"language-text\">F2&lt;Dog> :> F2&lt;Animal></code></li>\n</ul>\n<p><br><br></p>\n<p>타입스크립트의 타입은 기본적으로 공변성을 갖지만, 함수의 매개변수로 사용할 때 예외적으로 반공변성을 가집니다.</p>\n<p>즉, <u><strong>타입이 출력에 사용되면 공변, 입력에 사용되면 반공변</strong></u>합니다.</p>\n<br>\n<p>타입스크립트 컴파일러는 <code class=\"language-text\">\"strictFunctionTypes\": true</code>인 경우, 이렇게 변성에 의한 타입을 검사합니다. (tsconfig에서 설정)</p>\n<p>그리고 <strong>strictFunctionTypes</strong>를 활성화하지 않아도 변성을 검사할 수 있는 다른 방법이 존재합니다.</p>\n<p><br><br></p>\n<h5>Optional Variance Annotations</h5>\n<br>\n<p>TypeScript 4.7에서 도입된 <strong>Optional Variance Annotation</strong>을 사용하여, 매개변수의 변성을 명시할 수 있습니다.</p>\n<div class=\"gatsby-highlight\" data-language=\"ts\"><pre class=\"language-ts\"><code class=\"language-ts\"><span class=\"token keyword\">type</span> <span class=\"token class-name\"><span class=\"token constant\">F1</span><span class=\"token operator\">&lt;</span>out <span class=\"token constant\">T</span><span class=\"token operator\">></span></span> <span class=\"token operator\">=</span> <span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">=></span> <span class=\"token constant\">T</span><span class=\"token punctuation\">;</span></code></pre></div>\n<ul>\n<li><strong>공변성</strong>의 표기로 해당 타입 앞에 <code class=\"language-text\">out</code>을 사용할 수 있습니다.</li>\n</ul>\n<div class=\"gatsby-highlight\" data-language=\"ts\"><pre class=\"language-ts\"><code class=\"language-ts\"><span class=\"token keyword\">type</span> <span class=\"token class-name\"><span class=\"token constant\">F2</span><span class=\"token operator\">&lt;</span><span class=\"token keyword\">in</span> <span class=\"token constant\">T</span><span class=\"token operator\">></span></span> <span class=\"token operator\">=</span> <span class=\"token punctuation\">(</span>x<span class=\"token operator\">:</span> <span class=\"token constant\">T</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">=></span> <span class=\"token keyword\">void</span><span class=\"token punctuation\">;</span></code></pre></div>\n<ul>\n<li><strong>반공변성</strong>의 표기로 해당 타입 앞에 <code class=\"language-text\">in</code>을 사용할 수 있습니다.</li>\n</ul>\n<div class=\"gatsby-highlight\" data-language=\"ts\"><pre class=\"language-ts\"><code class=\"language-ts\"><span class=\"token keyword\">interface</span> <span class=\"token class-name\"><span class=\"token constant\">FF</span><span class=\"token operator\">&lt;</span><span class=\"token keyword\">in</span> out <span class=\"token constant\">T</span><span class=\"token operator\">></span></span> <span class=\"token punctuation\">{</span>\r\n  <span class=\"token function-variable function\">f1</span><span class=\"token operator\">:</span> <span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">=></span> <span class=\"token constant\">T</span><span class=\"token punctuation\">;</span>\r\n  <span class=\"token function-variable function\">f2</span><span class=\"token operator\">:</span> <span class=\"token punctuation\">(</span>x<span class=\"token operator\">:</span> <span class=\"token constant\">T</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">=></span> <span class=\"token keyword\">void</span><span class=\"token punctuation\">;</span>\r\n<span class=\"token punctuation\">}</span></code></pre></div>\n<ul>\n<li><strong>불변성</strong>의 표기로 해당 타입 앞에 <code class=\"language-text\">in out</code>을 사용할 수 있습니다.</li>\n</ul>\n<br>\n<p>다른 변성을 표기한다고 해서 변성이 바뀌지 않습니다. 오히려 에러만 뜹니다.</p>\n<p>변성을 명시함으로써 독자가 <u>매개변수의 용도를 알기 쉽게</u> 하고, 컴파일 과정 중 <u>타입 검사 속도를 높이는</u> 역할을 합니다.</p>\n<hr>\n<h3>Bivariance</h3>\n<p>공변성과 반공변성을 모두 갖는, <strong>이변성(Bivariance)</strong> 이 필요한 경우,</p>\n<br>\n<h6>1. strictFunctionTypes 비활성화</h6>\n<br>\n<p><u><strong>strictFunctionTypes</strong>를 비활성화하면</u>, 컴파일러는 변성 타입 검사를 하지 않으므로 <u><strong>변성과 관계없이 타입을 사용</strong></u>할 수 있습니다.</p>\n<p>물론 <u><strong>Optional Variance Annotation</strong>이 사용되었다면</u>, 해당 변성에 맞게 타입을 사용해야 합니다.</p>\n<p><br><br></p>\n<h6>2. Shorthand for Method definition</h6>\n<div class=\"gatsby-highlight\" data-language=\"ts\"><pre class=\"language-ts\"><code class=\"language-ts\"><span class=\"token keyword\">interface</span> <span class=\"token class-name\">Example<span class=\"token operator\">&lt;</span><span class=\"token constant\">T</span><span class=\"token operator\">></span></span> <span class=\"token punctuation\">{</span>\r\n  <span class=\"token function-variable function\">f1</span><span class=\"token operator\">:</span> <span class=\"token punctuation\">(</span>x<span class=\"token operator\">:</span> <span class=\"token constant\">T</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">=></span> <span class=\"token keyword\">void</span><span class=\"token punctuation\">;</span> <span class=\"token comment\">// Contravariance</span>\r\n  <span class=\"token function\">f2</span><span class=\"token punctuation\">(</span>x<span class=\"token operator\">:</span> <span class=\"token constant\">T</span><span class=\"token punctuation\">)</span><span class=\"token operator\">:</span> <span class=\"token keyword\">void</span><span class=\"token punctuation\">;</span> <span class=\"token comment\">// Bivariance</span>\r\n<span class=\"token punctuation\">}</span></code></pre></div>\n<ul>\n<li><u>메서드의 타입을 정의할 때</u>, ES6에서 도입된 Shorthand 문법을 사용하면 해당 메서드의 매개변수는 이변성을 갖습니다.</li>\n</ul>\n<p><br><br></p>\n<h6>3. bivarianceHack</h6>\n<div class=\"gatsby-highlight\" data-language=\"ts\"><pre class=\"language-ts\"><code class=\"language-ts\"><span class=\"token keyword\">type</span> <span class=\"token class-name\">Example<span class=\"token operator\">&lt;</span><span class=\"token constant\">T</span><span class=\"token operator\">></span></span> <span class=\"token operator\">=</span> <span class=\"token punctuation\">{</span> <span class=\"token function\">bivarianceHack</span><span class=\"token punctuation\">(</span>x<span class=\"token operator\">:</span> <span class=\"token constant\">T</span><span class=\"token punctuation\">)</span><span class=\"token operator\">:</span> <span class=\"token keyword\">void</span> <span class=\"token punctuation\">}</span><span class=\"token punctuation\">[</span><span class=\"token string\">'bivarianceHack'</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span></code></pre></div>\n<ul>\n<li><u>함수의 타입을 정의할 때</u>, 위와 같은 형식으로 작성하면 해당 함수의 매개변수는 이변성을 갖습니다.</li>\n</ul>\n<br>\n<p>원리는 아래와 같습니다.</p>\n<div class=\"gatsby-highlight\" data-language=\"ts\"><pre class=\"language-ts\"><code class=\"language-ts\"><span class=\"token number\">1.</span> <span class=\"token keyword\">type</span> <span class=\"token class-name\">Example<span class=\"token operator\">&lt;</span><span class=\"token constant\">T</span><span class=\"token operator\">></span></span> <span class=\"token operator\">=</span> <span class=\"token punctuation\">{</span> <span class=\"token function\">bivarianceHack</span><span class=\"token punctuation\">(</span>x<span class=\"token operator\">:</span> <span class=\"token constant\">T</span><span class=\"token punctuation\">)</span><span class=\"token operator\">:</span> <span class=\"token keyword\">void</span> <span class=\"token punctuation\">}</span><span class=\"token punctuation\">[</span><span class=\"token string\">'bivarianceHack'</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\r\n<span class=\"token number\">2.</span> <span class=\"token keyword\">type</span> <span class=\"token class-name\">Example<span class=\"token operator\">&lt;</span><span class=\"token constant\">T</span><span class=\"token operator\">></span></span> <span class=\"token operator\">=</span> <span class=\"token punctuation\">{</span> <span class=\"token function-variable function\">bivarianceHack</span><span class=\"token operator\">:</span> <span class=\"token punctuation\">(</span>x<span class=\"token operator\">:</span> <span class=\"token constant\">T</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">=></span> <span class=\"token keyword\">void</span> <span class=\"token punctuation\">}</span><span class=\"token punctuation\">[</span><span class=\"token string\">'bivarianceHack'</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\r\n<span class=\"token number\">3.</span> <span class=\"token keyword\">type</span> <span class=\"token class-name\">Example<span class=\"token operator\">&lt;</span><span class=\"token constant\">T</span><span class=\"token operator\">></span></span> <span class=\"token operator\">=</span> <span class=\"token punctuation\">(</span>x<span class=\"token operator\">:</span> <span class=\"token constant\">T</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">=></span> <span class=\"token keyword\">void</span><span class=\"token punctuation\">;</span></code></pre></div>\n<ol>\n<li>\n<p>Shorthand 문법을 사용하여 이변성을 갖습니다.</p>\n</li>\n<li>\n<p>Shorthand 문법을 풀고 기존 문법으로 치환해봅시다.</p>\n<ul>\n<li><code class=\"language-text\">{ key: value }['key'] = value;</code> 형식입니다.</li>\n</ul>\n</li>\n<li>\n<p>key가 일치하므로 value인 함수가 도출됩니다.</p>\n</li>\n</ol>\n<br>\n<p><strong>bivarianceHack</strong>은 리액트 타입에서 쓰이고 있습니다.</p>\n<div class=\"gatsby-highlight\" data-language=\"ts\"><pre class=\"language-ts\"><code class=\"language-ts\"><span class=\"token comment\">// index.d.ts</span>\r\n<span class=\"token keyword\">type</span> <span class=\"token class-name\">RefCallback<span class=\"token operator\">&lt;</span><span class=\"token constant\">T</span><span class=\"token operator\">></span></span> <span class=\"token operator\">=</span> <span class=\"token punctuation\">{</span> <span class=\"token function\">bivarianceHack</span><span class=\"token punctuation\">(</span>instance<span class=\"token operator\">:</span> <span class=\"token constant\">T</span> <span class=\"token operator\">|</span> <span class=\"token keyword\">null</span><span class=\"token punctuation\">)</span><span class=\"token operator\">:</span> <span class=\"token keyword\">void</span> <span class=\"token punctuation\">}</span><span class=\"token punctuation\">[</span><span class=\"token string\">'bivarianceHack'</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\r\n<span class=\"token keyword\">type</span> <span class=\"token class-name\">EventHandler<span class=\"token operator\">&lt;</span><span class=\"token constant\">E</span> <span class=\"token keyword\">extends</span> SyntheticEvent<span class=\"token operator\">&lt;</span><span class=\"token builtin\">any</span><span class=\"token operator\">>></span></span> <span class=\"token operator\">=</span> <span class=\"token punctuation\">{</span>\r\n  <span class=\"token function\">bivarianceHack</span><span class=\"token punctuation\">(</span>event<span class=\"token operator\">:</span> <span class=\"token constant\">E</span><span class=\"token punctuation\">)</span><span class=\"token operator\">:</span> <span class=\"token keyword\">void</span><span class=\"token punctuation\">;</span>\r\n<span class=\"token punctuation\">}</span><span class=\"token punctuation\">[</span><span class=\"token string\">'bivarianceHack'</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span></code></pre></div>\n<hr>\n<h3>참고 링크</h3>\n<ul>\n<li>\n<p><a href=\"https://stackoverflow.com/questions/52667959/what-is-the-purpose-of-bivariancehack-in-typescript-types\" target=\"_blank\" rel=\"nofollow\">What is the purpose of bivarianceHack in TypeScript types?</a></p>\n</li>\n<li>\n<p><a href=\"https://github.com/Microsoft/TypeScript/pull/18654\" target=\"_blank\" rel=\"nofollow\">Strict function types</a></p>\n</li>\n<li>\n<p><a href=\"https://github.com/Microsoft/TypeScript/wiki/FAQ#why-are-function-parameters-bivariant\" target=\"_blank\" rel=\"nofollow\">Why are function parameters bivariant?</a></p>\n</li>\n<li>\n<p><a href=\"https://seob.dev/posts/%EA%B3%B5%EB%B3%80%EC%84%B1%EC%9D%B4%EB%9E%80-%EB%AC%B4%EC%97%87%EC%9D%B8%EA%B0%80/\" target=\"_blank\" rel=\"nofollow\">공변성이란 무엇인가</a></p>\n</li>\n<li>\n<p><a href=\"https://driip.me/d230be64-df1d-4e9a-a8c2-cba6bbc0ae15\" target=\"_blank\" rel=\"nofollow\">TypeScript에서의 변성(Variance): 도대체 왜 이렇게 된 거야?</a></p>\n</li>\n<li>\n<p><a href=\"https://leestrument.tistory.com/entry/Typescript-Type-%EC%8B%9C%EC%8A%A4%ED%85%9C-%EC%9D%B4%ED%95%B4%ED%95%98%EA%B8%B0-Structural-Typing\" target=\"_blank\" rel=\"nofollow\">Typescript Type 시스템 이해하기 : Structural Typing</a></p>\n</li>\n<li>\n<p><a href=\"https://driip.me/644e7f06-8591-443e-9fca-44b0ab424fda\" target=\"_blank\" rel=\"nofollow\">TypeScript 4.7에 추가된 Type Parameters의 Variance Annotations</a></p>\n</li>\n<li>\n<p><a href=\"https://devblogs.microsoft.com/typescript/announcing-typescript-4-7/#optional-variance-annotations-for-type-parameters\" target=\"_blank\" rel=\"nofollow\">Optional Variance Annotations for Type Parameters</a></p>\n</li>\n<li>\n<p><a href=\"https://radlohead.gitbook.io/typescript-deep-dive/type-system/type-compatibility\" target=\"_blank\" rel=\"nofollow\">타입 호환성</a></p>\n</li>\n</ul>","frontmatter":{"title":"TypeScript 타입 변성(Variance)","summary":"타입스크립트에서 다루는 타입 변성에 대하여","date":"2022.09.20.","categories":["TS"],"thumbnail":{"childImageSharp":{"gatsbyImageData":{"layout":"constrained","placeholder":{"fallback":"data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAKCAYAAAC0VX7mAAAACXBIWXMAAAuIAAALiAHljilJAAAA2UlEQVQoz2P4jwX8+/cPTv/5i4qR5bABhv84AC4NhOQY8Gl4/enn/wNX3/4/fOPd/0PX34HpL9//kO7C338gihcfevpfJuvAf9WCQ//VCg//l885+P/ozfdgOZD3STZw4cGn/02qjv0Pm3Dhv1fH2f/Ozaf/H7nxjnwDFxx48t+h6dT/FUef/Z+w7cH/1vV3/x+49pZ8A+cfePJfNvvA/+LFN/6HT7zwv3/bA7iX/5Ji4F9ogD94/e3/siPP/q8//fL/tvOv/2+/8Pr/m08/B1GyAbn0N4kJGwDwKf3bO5P6PwAAAABJRU5ErkJggg=="},"images":{"fallback":{"src":"/static/9e4e8b973753a1f467ef26149a26eb36/e51b9/Typescript_logo_2020.png","srcSet":"/static/9e4e8b973753a1f467ef26149a26eb36/c82f0/Typescript_logo_2020.png 117w,\n/static/9e4e8b973753a1f467ef26149a26eb36/abe34/Typescript_logo_2020.png 235w,\n/static/9e4e8b973753a1f467ef26149a26eb36/e51b9/Typescript_logo_2020.png 469w","sizes":"(min-width: 469px) 469px, 100vw"},"sources":[{"srcSet":"/static/9e4e8b973753a1f467ef26149a26eb36/fe6dc/Typescript_logo_2020.webp 117w,\n/static/9e4e8b973753a1f467ef26149a26eb36/cbc6d/Typescript_logo_2020.webp 235w,\n/static/9e4e8b973753a1f467ef26149a26eb36/a4036/Typescript_logo_2020.webp 469w","type":"image/webp","sizes":"(min-width: 469px) 469px, 100vw"}]},"width":469,"height":234}},"publicURL":"/static/9e4e8b973753a1f467ef26149a26eb36/Typescript_logo_2020.png"}}}}]}},"pageContext":{"slug":"/Variance/","next":{"fields":{"slug":"/Neaflix/"},"frontmatter":{"title":"NAEFLIX"}},"prev":{"fields":{"slug":"/Debounce&Throttle/"},"frontmatter":{"title":"Debounce & Throttle 함수 만들기"}}}},"staticQueryHashes":[]}