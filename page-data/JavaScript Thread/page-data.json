{"componentChunkName":"component---src-templates-post-template-tsx","path":"/JavaScript Thread/","result":{"data":{"allMarkdownRemark":{"edges":[{"node":{"html":"<p>자바스크립트를 더욱 이해하려고 보니, 단순 암기로만 알고 있던 정보들에 아래와 같은 의문들이 생겼습니다.</p>\n<br>\n<ul>\n<li>\n<p>자바스크립트는 언어인데, 왜 Single thread라고 하는 걸까?</p>\n</li>\n<li>\n<p>Web API, Promise와 같은 비동기 작업은 어느 thread에서 처리할까?</p>\n</li>\n<li>\n<p>Event Loop가 Main thread에서 발생한다는데, Main thread는 어디에 있을까?</p>\n</li>\n<li>\n<p>Node.js 환경에서는 Web API를 어떻게 처리할까?</p>\n</li>\n</ul>\n<br>\n<p>이런 의문들을 풀기 위해 수집한 정보들을 정리하였습니다.</p>\n<p>혹 틀린 부분이 있다면 댓글 부탁드립니다.</p>\n<hr>\n<blockquote>\n<p>Single thread?</p>\n</blockquote>\n<p>자바스크립트는 경량화를 위해 Single thread 환경에서 실행되도록 만들어진 언어입니다.</p>\n<p>때문에 자바스크립트 엔진이 Single thread로 동작하는 것이고, 따라서 Call stack이 하나라는 의미가 되기도 합니다.</p>\n<blockquote>\n<p>Call stack?</p>\n</blockquote>\n<p>함수의 호출 상황을 기록하고 제어하는 메커니즘입니다.</p>\n<p>함수가 호출되면 해당 함수의 실행 컨텍스트가 Call stack에 추가된 후 함수가 처리됩니다.</p>\n<p>콜 스택은 자바스크립트 엔진에 포함되어 있습니다.</p>\n<blockquote>\n<p>자바스크립트 엔진?</p>\n</blockquote>\n<p>자바스크립트 엔진은 자바스크립트를 해석하고 실행하는 역할을 합니다.</p>\n<p>대표적으로 V8이 있으며, 자바스크립트 런타임(브라우저, Node.js)에 내장되어 있습니다.</p>\n<p>자바스크립트 엔진이 Single thread로 동작하기 때문에, Event Loop도 하나만 있으면 됩니다.</p>\n<p>따라서 Event Loop가 발생하는 Main thread도 하나입니다.</p>\n<blockquote>\n<p>Main thread?</p>\n</blockquote>\n<p>모든 브라우저는 자바스크립트 엔진과 브라우저 엔진(렌더링 엔진)이 존재합니다.</p>\n<p>크롬의 경우 Webkit을 포크한 Blink라는 브라우저 엔진을 사용하고 있습니다.</p>\n<p>Node.js는 비슷한 역할을 하는 libuv라는 라이브러리가 있습니다.</p>\n<br>\n<p>Main thread는 브라우저 엔진의 렌더러 프로세스에 존재하며, 브라우저로 전송된 대부분의 코드를 처리합니다.</p>\n<p>HTML과 CSS를 파싱하고, 레이아웃 트리를 만드는 등 렌더링 작업의 대부분을 처리하고 지휘합니다.</p>\n<p>여기서 다룰 점은 Main thread는 자바스크립트 엔진과 별개의 thread이고, <strong>Event Loop를 담당</strong>한다는 점입니다.</p>\n<blockquote>\n<p>Event Loop?</p>\n</blockquote>\n<p>Event Loop는 비동기적인 코드의 실행을 관리하며, 이벤트 발생과 처리를 조율합니다.</p>\n<p>콜 스택이 비었을 때, <strong>Task queue에 쌓인 태스크를 Call stack으로 넘겨 실행</strong>하는 역할을 합니다.</p>\n<p>Task queue가 비었을 때는 동작하지 않고, 태스크가 있을 때 반복 동작합니다.</p>\n<p>콜 스택이 비었음을 확인하고, 태스크를 처리하는 과정을 반복하기에 Loop라고 합니다.</p>\n<blockquote>\n<p>Task queue?</p>\n</blockquote>\n<p>Task queue는 이벤트 큐 혹은 콜백 큐라고도 불리며, 보통 Macrotask queue를 가리킵니다.</p>\n<p>하지만 V8에는 Microtask queue의 개념도 존재합니다.</p>\n<br>\n<ul>\n<li>\n<p>Microtask queue에는 Promise, async/await, queueMicrotask으로 처리한 태스크가 쌓입니다.</p>\n</li>\n<li>\n<p>Macrotask queue에는 이벤트 핸들러, setTimeout, setInterval, etc에서 처리한 태스크가 쌓입니다.</p>\n</li>\n</ul>\n<br>\n<p>Event Loop 과정에서 Microtask를 우선 처리합니다.</p>\n<p>따라서 Microtask queue의 태스크를 모두 처리한 이후에 Macrotask를 처리합니다.</p>\n<hr>\n<h4>Event Loop Map</h4>\n<br>\n<p>Thread를 중심으로 Event Loop Map을 도식화하였습니다.</p>\n<p>크롬을 기준으로 하였고, Blink 로고가 존재하지 않아 Webkit 로고로 대체하였습니다.</p>\n<p>간소화한 것이라 생략된 개념이 존재합니다.</p>\n<p><span\n      class=\"gatsby-resp-image-wrapper\"\n      style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 768px; \"\n    >\n      <a\n    class=\"gatsby-resp-image-link\"\n    href=\"/static/f55ed1f39a0ae0c9aa8bf76fd4827d34/c3dd4/Javascript-thread.png\"\n    style=\"display: block\"\n    target=\"_blank\"\n    rel=\"noopener\"\n  >\n    <span\n    class=\"gatsby-resp-image-background-image\"\n    style=\"padding-bottom: 58.854166666666664%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAMCAYAAABiDJ37AAAACXBIWXMAAA7EAAAOxAGVKw4bAAAB1klEQVQoz3WSW4vbMBCF8/9/RaEvfSqUPhS29K2FQpdusAnZLq43aRLb8V2yZfmaU84kXpKWFQyWxjPfzNFocTqdMI4jpmkC9+d1kjP9XMl6jerpAfL3NAAYMU6TxMzGWOYv6rqG1hpVVSHPUji/djgER1RaQ2mN3lq8+/IBP76+wdgaOAHNwugSpVJQSknuzBBg3/dQSsOaCm8/7+DtcgydRZ7n0PQPFnVrgHHCx+93eP/tE6a+FwiBSZIIjCwBNk0Day2UKuE//0EQhCI1TVMURYHjMUYURjjGGfr8CW26RmVamIs6QrMsgzHmDGzbVuj7/R7Pvg/f96UIgyidgeygMQZ1MyCKCxwOe4HNCue9ANkdk/5dlNK07Y2PhaIwRBAEiONYmmDcq0BOap52kqawZQkMA9B14uu6ThJ5FZRKKI3nF8mvAbPHR+SrFbTvo/Q86SLNMulqs9kgDEPJOw9V3XZIKTdrGFC4Ljb391iuVvi5XMJ1XTiOgyiKJJkwwnnXN0AOpSxLkUO47Tq0WiNzXQSXIf32PGy3W9nzObEBfnmXLECgSKaMWTLhL2YMTN/L42Wx+asuj1ldnQnkE+N+Qf2EseJ/Zsy54yub/1375mdFhX8B0bqUBN86QtkAAAAASUVORK5CYII='); background-size: cover; display: block;\"\n  ></span>\n  <picture>\n          <source\n              srcset=\"/static/f55ed1f39a0ae0c9aa8bf76fd4827d34/a59e9/Javascript-thread.webp 192w,\n/static/f55ed1f39a0ae0c9aa8bf76fd4827d34/0ca9f/Javascript-thread.webp 384w,\n/static/f55ed1f39a0ae0c9aa8bf76fd4827d34/dc9b9/Javascript-thread.webp 768w,\n/static/f55ed1f39a0ae0c9aa8bf76fd4827d34/8b443/Javascript-thread.webp 788w\"\n              sizes=\"(max-width: 768px) 100vw, 768px\"\n              type=\"image/webp\"\n            />\n          <source\n            srcset=\"/static/f55ed1f39a0ae0c9aa8bf76fd4827d34/3b721/Javascript-thread.png 192w,\n/static/f55ed1f39a0ae0c9aa8bf76fd4827d34/66595/Javascript-thread.png 384w,\n/static/f55ed1f39a0ae0c9aa8bf76fd4827d34/fe486/Javascript-thread.png 768w,\n/static/f55ed1f39a0ae0c9aa8bf76fd4827d34/c3dd4/Javascript-thread.png 788w\"\n            sizes=\"(max-width: 768px) 100vw, 768px\"\n            type=\"image/png\"\n          />\n          <img\n            class=\"gatsby-resp-image-image\"\n            src=\"/static/f55ed1f39a0ae0c9aa8bf76fd4827d34/fe486/Javascript-thread.png\"\n            alt=\"Javascript thread\"\n            title=\"Javascript thread\"\n            loading=\"lazy\"\n            decoding=\"async\"\n            style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\"\n          />\n        </picture>\n  </a>\n    </span></p>\n<ol>\n<li>\n<p>비동기 함수가 호출되면 실행 컨텍스트가 콜 스택에 쌓이지 않고, 브라우저 엔진의 해당 스레드에 생성됩니다.</p>\n</li>\n<li>\n<p>해당 스레드에서 비동기 함수를 처리 후, 그 결과(태스크)가 태스크 큐에 쌓입니다.</p>\n</li>\n<li>\n<p>처리할 태스크가 있으니 메인 스레드에서 이벤트 루프를 통해 콜 스택이 비었는지 확인합니다.</p>\n</li>\n</ol>\n<p>4-1. 콜 스택이 비었다면, 이벤트 루프를 통해 큐에 쌓인 태스크를 콜 스택으로 넘깁니다.</p>\n<p>4-2. 콜 스택이 차 있다면, 콜 스택이 빌 때까지 기다립니다.</p>\n<br>\n<p>브라우저는 다양한 프로세스로 구성되어 있고, 프로세스는 다양한 스레드로 구성되어 있습니다.</p>\n<p>앞서 말한 것처럼 메인 스레드는 렌더러 프로세스에 속하듯, 각 스레드는 속하는 프로세스가 존재합니다.</p>\n<p>다른 프로세스에 속하는 스레드 간 통신은 IPC(Inter Process Communication)를 이용합니다.</p>\n<p><br><br></p>\n<h4>정리</h4>\n<br>\n<ul>\n<li>\n<p>자바스크립트는 Single thread 언어이지만, 런타임의 여러 스레드를 이용하기에 Multi thread로 동작한다.</p>\n</li>\n<li>\n<p>자바스크립트 엔진이 동작하는 동안 브라우저 엔진이 다른 태스크를 처리하기에 비동기적 처리가 가능하다.</p>\n<ul>\n<li>Node.js의 경우 libuv 라이브러리의 Thread pool에서 처리한다.</li>\n</ul>\n</li>\n<li>\n<p>브라우저 엔진이 처리한 태스크는 큐에 쌓이며, 이는 이벤트 루프를 통해 콜 스택으로 넘어가 실행된다.</p>\n</li>\n</ul>\n<hr>\n<h3>참고 링크</h3>\n<ul>\n<li>\n<p><a href=\"https://www.youtube.com/watch?v=8aGhZQkoFbQ&#x26;ab_channel=JSConf\" target=\"_blank\" rel=\"nofollow\">어쨌든 이벤트 루프는 무엇입니까? | Philip Roberts | JSConf EU</a></p>\n</li>\n<li>\n<p><a href=\"hhttps://d2.naver.com/helloworld/5237120\" target=\"_blank\" rel=\"nofollow\">최신 브라우저의 내부 살펴보기 3 - 렌더러 프로세스의 내부 동작</a></p>\n</li>\n<li>\n<p><a href=\"https://ko.javascript.info/event-loop\" target=\"_blank\" rel=\"nofollow\">이벤트 루프와 매크로태스크, 마이크로태스크</a></p>\n</li>\n<li>\n<p><a href=\"https://youngju-js.tistory.com/28\" target=\"_blank\" rel=\"nofollow\">[JavaScript] 이벤트 루프(Event loop) 정리</a></p>\n</li>\n<li>\n<p><a href=\"https://miracleground.tistory.com/entry/%EC%9E%90%EB%B0%94%EC%8A%A4%ED%81%AC%EB%A6%BD%ED%8A%B8%EB%8A%94-%EC%99%9C-%EC%8B%B1%EA%B8%80-%EC%8A%A4%EB%A0%88%EB%93%9C%EB%A5%BC-%EC%84%A0%ED%83%9D%ED%96%88%EC%9D%84%EA%B9%8C-%ED%94%84%EB%A1%9C%EC%84%B8%EC%8A%A4-%EC%8A%A4%EB%A0%88%EB%93%9C-%EB%B9%84%EB%8F%99%EA%B8%B0-%EB%8F%99%EA%B8%B0-%EC%9E%90%EB%B0%94%EC%8A%A4%ED%81%AC%EB%A6%BD%ED%8A%B8-%EC%97%94%EC%A7%84-%EC%9D%B4%EB%B2%A4%ED%8A%B8%EB%A3%A8%ED%94%84\" target=\"_blank\" rel=\"nofollow\">자바스크립트는 왜 싱글 스레드를 선택했을까? 프로세스, 스레드, 비동기, 동기, 자바스크립트 엔진, 이벤트루프</a></p>\n</li>\n<li>\n<p><a href=\"https://beomy.github.io/tech/browser/browser-rendering/\" target=\"_blank\" rel=\"nofollow\">[Browser] 브라우저 렌더링</a></p>\n</li>\n<li>\n<p><a href=\"https://www.korecmblog.com/node-js-event-loop/\" target=\"_blank\" rel=\"nofollow\">Node.js 이벤트 루프(Event Loop) 샅샅이 분석하기</a></p>\n</li>\n<li>\n<p><a href=\"https://chat.openai.com/chat\" target=\"_blank\" rel=\"nofollow\">ChatGPT</a></p>\n</li>\n</ul>","frontmatter":{"title":"JavaScript Thread & Event Loop","summary":"자바스크립트 스레드와 이벤트 루프 관련 정보들 & Event Loop Map","date":"2023.02.28.","categories":["JS"],"thumbnail":{"childImageSharp":{"gatsbyImageData":{"layout":"constrained","placeholder":{"fallback":"data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAALCAYAAAB/Ca1DAAAACXBIWXMAAA7EAAAOxAGVKw4bAAABBklEQVQoz52SMUsDQRCFVy2EVEJia5NfYmthY2VnoUUKrcTGUkQsTOFP0DRaaC/YKoLYaCPRBBGRoEY9Yu64nZ1PvEQ00T24PBhmYed9O7DP8I9UtdsdqravpGemXwaPfIbvh3wyaQYXXWKDCjbYTyp+30Xap6lQD9AmPX5Z56M6QljLE9ULxPUh4sZ8z0w2YLNMWCsQVIu8XRe5Px+j/bg0ODB63oLGOBdHEyyX8qyUhmk9LHZm3EAbbhDejLK9lmNzNcfCrOHseC65E8kEFL7+WFt7vN5OcViZ5upkhoOdSZ7uyt0NJVtsQPElJy1SxmfoeDQ5iyjOKVb0V+g1G/AH/LfSgJ9H1UgnE7LTsQAAAABJRU5ErkJggg=="},"images":{"fallback":{"src":"/static/c6353991827688bbdcebbe960ab5d369/d2355/js.png","srcSet":"/static/c6353991827688bbdcebbe960ab5d369/e8fbe/js.png 175w,\n/static/c6353991827688bbdcebbe960ab5d369/c0907/js.png 350w,\n/static/c6353991827688bbdcebbe960ab5d369/d2355/js.png 700w","sizes":"(min-width: 700px) 700px, 100vw"},"sources":[{"srcSet":"/static/c6353991827688bbdcebbe960ab5d369/b1534/js.webp 175w,\n/static/c6353991827688bbdcebbe960ab5d369/659a6/js.webp 350w,\n/static/c6353991827688bbdcebbe960ab5d369/c4944/js.webp 700w","type":"image/webp","sizes":"(min-width: 700px) 700px, 100vw"}]},"width":700,"height":400}},"publicURL":"/static/c6353991827688bbdcebbe960ab5d369/js.png"}}}}]}},"pageContext":{"slug":"/JavaScript Thread/","next":null,"prev":{"fields":{"slug":"/ChatGPT-webpack&babel/"},"frontmatter":{"title":"ChatGPT와 함께: webpack, Babel, Flow"}}}},"staticQueryHashes":[]}